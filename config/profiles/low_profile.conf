# ═══════════════════════════════════════════════════════════════════
#  Avrix Low-End Profile Configuration
#  Target: 8-bit MCUs with minimal resources (128B-4KB RAM, 4-32KB Flash)
# ═══════════════════════════════════════════════════════════════════
#
#  POSIX Profile: PSE51 (Minimal realtime system profile)
#  Features: Single process, cooperative/simple preemptive scheduler
#  No: filesystem, networking, dynamic memory, fork/exec
#
#  Example Targets:
#  - Intel 8051 (128B RAM, 4KB ROM)
#  - ATmega16U2 (512B SRAM, 16KB Flash)
#  - ATmega32 (2KB SRAM, 32KB Flash) - lower tier
#  - ATmega328P (2KB SRAM, 32KB Flash) - upper tier
#
# ═══════════════════════════════════════════════════════════════════

[profile]
name = "low-end"
tier = "low"
description = "8-bit MCUs with minimal resources"
posix_profile = "PSE51"
min_ram_bytes = 128
max_ram_bytes = 4096
min_flash_bytes = 4096
max_flash_bytes = 32768

# ───────────────────────────────────────────────────────────────────
# SCHEDULER CONFIGURATION
# ───────────────────────────────────────────────────────────────────

[scheduler]
type = "simple"                 # Options: simple, preemptive, full
mode = "cooperative"            # Options: cooperative, preemptive
max_tasks = 4                   # Maximum number of tasks (including idle)
stack_size_bytes = 64           # Per-task stack size
quantum_ms = 0                  # No time-slicing (cooperative)
priority_levels = 4             # 0 (high) to 3 (low)
scheduling_policy = "fifo"      # Options: fifo, round_robin
enable_sleep = true             # Task sleep support
enable_dag_wait = false         # DAG dependency tracking
enable_stack_guard = false      # Stack overflow detection (costs RAM)

# ───────────────────────────────────────────────────────────────────
# MEMORY MANAGEMENT
# ───────────────────────────────────────────────────────────────────

[memory]
allocator = "none"              # Options: none, bump, fixed_pool, full
heap_size_bytes = 0             # No dynamic allocation
enable_malloc = false           # No malloc/free
enable_mpu = false              # No Memory Protection Unit
static_only = true              # All allocation at compile-time

# ───────────────────────────────────────────────────────────────────
# IPC & SYNCHRONIZATION
# ───────────────────────────────────────────────────────────────────

[ipc]
enable_door_rpc = false         # Door RPC (too heavy for low-end)
enable_pipes = false            # POSIX pipes
enable_message_queues = false   # POSIX message queues
enable_shared_memory = false    # Shared memory

[sync]
enable_spinlock = true          # Basic spinlocks
enable_mutex = false            # POSIX mutexes (requires threading)
enable_semaphore = false        # POSIX semaphores
enable_rwlock = false           # Read-write locks
lock_type = "simple_tas"        # Options: simple_tas, atomic, interrupt_disable

# ───────────────────────────────────────────────────────────────────
# FILESYSTEM
# ───────────────────────────────────────────────────────────────────

[filesystem]
enable = false                  # No filesystem support
vfs = false                     # No VFS layer
types = []                      # No FS types
max_open_files = 0
max_path_length = 0

# ───────────────────────────────────────────────────────────────────
# NETWORKING
# ───────────────────────────────────────────────────────────────────

[networking]
enable = false                  # No networking support
stack = "none"                  # Options: none, slip, lwip
protocols = []                  # No protocols
max_sockets = 0

# ───────────────────────────────────────────────────────────────────
# DRIVERS
# ───────────────────────────────────────────────────────────────────

[drivers]
enable_uart = true              # UART for debugging/console
enable_spi = false              # SPI
enable_i2c = false              # I2C
enable_gpio = true              # GPIO (basic I/O)
enable_timer = true             # System timer (for scheduler)
enable_adc = false              # ADC
enable_pwm = false              # PWM

# ───────────────────────────────────────────────────────────────────
# POSIX API
# ───────────────────────────────────────────────────────────────────

[posix]
profile = "PSE51"               # Minimal realtime system profile

# Process management (all stubs)
fork = "stub"                   # fork() returns ENOSYS
exec = "stub"                   # exec*() returns ENOSYS
waitpid = "stub"                # waitpid() returns ENOSYS

# I/O (minimal)
open = "stub"                   # open() returns ENOSYS (no FS)
read = "stub"                   # read() returns ENOSYS
write = "stub"                  # write() returns ENOSYS (or console redirect)
close = "stub"                  # close() returns ENOSYS

# unistd (minimal)
sleep = "basic"                 # sleep() using scheduler
usleep = "stub"                 # usleep() returns ENOSYS
getpid = "basic"                # getpid() returns task ID

# Threading (disabled in cooperative mode)
pthread_create = "stub"         # pthread_create() returns ENOSYS
pthread_join = "stub"           # pthread_join() returns ENOSYS
pthread_mutex = "stub"          # All mutex functions return ENOSYS

# Signals (not supported)
signal = "stub"                 # signal() returns ENOSYS
kill = "stub"                   # kill() returns ENOSYS

# ───────────────────────────────────────────────────────────────────
# BUILD & OPTIMIZATION
# ───────────────────────────────────────────────────────────────────

[build]
optimization = "s"              # -Os (optimize for size)
lto = true                      # Link-time optimization
debug_symbols = false           # No debug symbols (save flash)
assertions = false              # No runtime assertions
warnings_as_errors = true       # Treat warnings as errors
stack_usage_check = true        # Check stack usage at compile-time
size_gate = true                # Enforce flash/RAM limits

# Size limits
flash_limit_bytes = 4096        # Firmware must fit in 4KB
ram_limit_bytes = 512           # SRAM budget: 512 bytes max
stack_limit_per_task = 64       # 64 bytes per task stack

# ───────────────────────────────────────────────────────────────────
# FEATURES (DISABLED FOR LOW-END)
# ───────────────────────────────────────────────────────────────────

[features]
threading = false               # No multithreading
filesystem = false              # No filesystem
networking = false              # No networking
usb = false                     # No USB
crypto = false                  # No cryptography
gui = false                     # No GUI
floating_point = false          # No FP (software FP too slow/large)
dynamic_loading = false         # No runtime module loading

# ───────────────────────────────────────────────────────────────────
# DEBUGGING & DIAGNOSTICS (MINIMAL)
# ───────────────────────────────────────────────────────────────────

[debug]
enable_gdb_stub = false         # No on-device GDB stub (too large)
enable_uart_console = true      # UART console for printf debugging
enable_assertions = false       # No assertions (save flash)
enable_profiling = false        # No profiling
enable_tracing = false          # No tracing

# ───────────────────────────────────────────────────────────────────
# EXAMPLES COMPATIBLE WITH THIS PROFILE
# ───────────────────────────────────────────────────────────────────

[examples]
# Examples that fit in low-end constraints
compatible = [
    "blinky",                   # Simple LED blink (no OS)
    "cooperative_tasks",        # 2-4 tasks, cooperative yield
    "simple_uart_echo",         # UART echo server
    "gpio_polling"              # GPIO input/output polling
]

# ───────────────────────────────────────────────────────────────────
# NOTES
# ───────────────────────────────────────────────────────────────────

[notes]
summary = """
Low-end profile for extremely constrained 8-bit microcontrollers.
Provides basic task management with cooperative scheduling and minimal
I/O. Suitable for simple control applications, sensor reading, and
basic automation. No POSIX file I/O, networking, or dynamic memory.
"""

limitations = """
- No filesystem (open/read/write are stubs)
- No networking
- No dynamic memory allocation (malloc/free unavailable)
- No threading (single-process, cooperative tasks only)
- No fork/exec (process management stubs)
- No signals
- Minimal stack space (64 bytes per task)
- Total RAM budget: ~512 bytes
"""

best_practices = """
1. Use static allocation only
2. Keep task count minimal (2-4 tasks)
3. Avoid deep function call stacks (max 4-5 levels)
4. Use fixed-point arithmetic instead of floating-point
5. Store constants in flash (PROGMEM on AVR)
6. Profile flash and RAM usage with size-gate
7. Test on real hardware early (emulation may hide issues)
"""
