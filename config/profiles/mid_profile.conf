# ═══════════════════════════════════════════════════════════════════
#  Avrix Mid-Range Profile Configuration
#  Target: Enhanced 8-bit and 16-bit MCUs (4-16KB RAM, 32-128KB Flash)
# ═══════════════════════════════════════════════════════════════════
#
#  POSIX Profile: PSE52+ (Multi-threaded with optional filesystem)
#  Features: Preemptive multitasking, filesystem, networking (optional)
#  Limited: Dynamic memory (small heap), no fork/exec
#
#  Example Targets:
#  - ATmega128/128A (4KB SRAM, 128KB Flash)
#  - ATmega1280/1281 (8KB SRAM, 128KB Flash)
#  - ATmega1284P (16KB SRAM, 128KB Flash)
#  - MSP430F5529 (8KB RAM, 128KB Flash)
#  - PIC24FJ128 (8KB RAM, 128KB Flash)
#
# ═══════════════════════════════════════════════════════════════════

[profile]
name = "mid-range"
tier = "mid"
description = "Enhanced 8-bit and 16-bit MCUs"
posix_profile = "PSE52"         # Multi-threaded, optional FS
min_ram_bytes = 4096            # 4 KB
max_ram_bytes = 16384           # 16 KB
min_flash_bytes = 32768         # 32 KB
max_flash_bytes = 131072        # 128 KB

# ───────────────────────────────────────────────────────────────────
# SCHEDULER CONFIGURATION
# ───────────────────────────────────────────────────────────────────

[scheduler]
type = "preemptive"             # Options: simple, preemptive, full
mode = "preemptive"             # Preemptive multitasking
max_tasks = 16                  # Maximum number of tasks
stack_size_bytes = 128          # Per-task stack size
quantum_ms = 10                 # Time-slice: 10 ms
priority_levels = 16            # 0 (high) to 15 (low)
scheduling_policy = "priority"  # Options: fifo, round_robin, priority
enable_sleep = true             # Task sleep support
enable_dag_wait = true          # DAG dependency tracking
enable_stack_guard = true       # Stack overflow detection
tick_frequency_hz = 1000        # 1 kHz system tick

# ───────────────────────────────────────────────────────────────────
# MEMORY MANAGEMENT
# ───────────────────────────────────────────────────────────────────

[memory]
allocator = "fixed_pool"        # Options: none, bump, fixed_pool, full
heap_size_bytes = 1024          # 1 KB heap for dynamic allocation
enable_malloc = true            # malloc/free available (limited)
enable_mpu = false              # No MPU on most mid-range MCUs
static_only = false             # Allow dynamic allocation

# Heap configuration
pool_block_sizes = [8, 16, 32, 64, 128]  # Fixed pool sizes
pool_block_counts = [8, 8, 4, 2, 1]      # Blocks per size

# ───────────────────────────────────────────────────────────────────
# IPC & SYNCHRONIZATION
# ───────────────────────────────────────────────────────────────────

[ipc]
enable_door_rpc = true          # Door RPC (zero-copy IPC)
door_slots_per_task = 4         # Door descriptors per task
door_slab_size_bytes = 128      # Shared payload buffer
enable_pipes = false            # POSIX pipes (optional, heavy)
enable_message_queues = false   # POSIX message queues
enable_shared_memory = false    # Shared memory

[sync]
enable_spinlock = true          # Spinlocks
enable_mutex = true             # POSIX mutexes
enable_semaphore = true         # POSIX semaphores
enable_rwlock = false           # Read-write locks (optional)
enable_condvar = false          # Condition variables (optional)
lock_type = "tas_with_fair"     # Options: simple_tas, tas_with_fair, atomic

# Priority inheritance
enable_priority_inheritance = false  # Too complex for mid-range

# ───────────────────────────────────────────────────────────────────
# FILESYSTEM
# ───────────────────────────────────────────────────────────────────

[filesystem]
enable = true                   # Filesystem support
vfs = true                      # VFS layer
types = ["ramfs", "romfs", "eepfs"]  # Available FS types
max_open_files = 8              # Max open file descriptors
max_path_length = 64            # Max path string length
enable_cwd = false              # Current working directory

# RAMFS (in-memory filesystem)
ramfs_blocks = 16               # Number of blocks
ramfs_block_size = 32           # Block size in bytes
ramfs_inodes = 16               # Number of inodes

# ROMFS (read-only filesystem in flash)
romfs_enable = true             # Enable ROMFS
romfs_max_files = 32            # Max files in ROMFS

# EEPFS (EEPROM-backed filesystem)
eepfs_enable = true             # Enable EEPFS
eepfs_wear_leveling = true      # TinyLog-4 wear-leveling

# ───────────────────────────────────────────────────────────────────
# NETWORKING
# ───────────────────────────────────────────────────────────────────

[networking]
enable = true                   # Networking support (optional)
stack = "slip"                  # Options: none, slip, minimal_tcp, lwip
protocols = ["ipv4"]            # Supported protocols
max_sockets = 4                 # Max concurrent sockets
enable_dns = false              # DNS resolver
enable_dhcp = false             # DHCP client

# SLIP configuration
slip_mtu = 256                  # MTU for SLIP packets
slip_enable_crc = true          # CRC checksum

# Minimal TCP/UDP (optional)
tcp_enable = false              # Basic TCP (experimental)
udp_enable = false              # Basic UDP (experimental)

# ───────────────────────────────────────────────────────────────────
# DRIVERS
# ───────────────────────────────────────────────────────────────────

[drivers]
enable_uart = true              # UART (multi-UART if available)
uart_count = 2                  # Number of UART interfaces
enable_spi = true               # SPI
enable_i2c = true               # I2C
enable_gpio = true              # GPIO
enable_timer = true             # System timer
enable_rtc = false              # Real-time clock (optional)
enable_adc = true               # ADC
enable_pwm = true               # PWM
enable_watchdog = true          # Watchdog timer
enable_eeprom = true            # EEPROM driver

# ───────────────────────────────────────────────────────────────────
# POSIX API
# ───────────────────────────────────────────────────────────────────

[posix]
profile = "PSE52"               # Multi-threaded system profile

# Process management (most are stubs)
fork = "stub"                   # fork() returns ENOSYS
exec = "stub"                   # exec*() returns ENOSYS
waitpid = "stub"                # waitpid() returns ENOSYS
getpid = "basic"                # getpid() returns task ID

# I/O (filesystem-backed)
open = "full"                   # open() with VFS
read = "full"                   # read() from file descriptors
write = "full"                  # write() to file descriptors
close = "full"                  # close() file descriptors
lseek = "basic"                 # lseek() for seeking
stat = "basic"                  # stat() for file info

# unistd
sleep = "full"                  # sleep() using scheduler
usleep = "basic"                # usleep() (millisecond precision)
getcwd = "stub"                 # getcwd() returns ENOSYS (no CWD)
chdir = "stub"                  # chdir() returns ENOSYS

# Threading (PSE52 core)
pthread_create = "full"         # pthread_create() with scheduler
pthread_join = "full"           # pthread_join()
pthread_exit = "full"           # pthread_exit()
pthread_mutex = "full"          # pthread_mutex_* functions
pthread_cond = "stub"           # pthread_cond_* returns ENOSYS (optional)
pthread_rwlock = "stub"         # pthread_rwlock_* returns ENOSYS
pthread_barrier = "stub"        # pthread_barrier_* returns ENOSYS

# Signals (limited support)
signal = "stub"                 # signal() returns ENOSYS
kill = "stub"                   # kill() returns ENOSYS

# Sockets (if networking enabled)
socket = "basic"                # socket() for SLIP/IPv4
bind = "basic"                  # bind()
connect = "basic"               # connect()
sendto = "basic"                # sendto()
recvfrom = "basic"              # recvfrom()
select = "stub"                 # select() returns ENOSYS (too heavy)

# ───────────────────────────────────────────────────────────────────
# BUILD & OPTIMIZATION
# ───────────────────────────────────────────────────────────────────

[build]
optimization = "s"              # -Os (optimize for size)
lto = true                      # Link-time optimization
debug_symbols = false           # No debug symbols in release
assertions = true               # Runtime assertions (debug builds)
warnings_as_errors = true       # Treat warnings as errors
stack_usage_check = true        # Check stack usage
size_gate = true                # Enforce flash/RAM limits

# Size limits
flash_limit_bytes = 131072      # 128 KB flash limit
ram_limit_bytes = 8192          # 8 KB SRAM budget (conservative)
stack_limit_per_task = 128      # 128 bytes per task stack

# ───────────────────────────────────────────────────────────────────
# FEATURES
# ───────────────────────────────────────────────────────────────────

[features]
threading = true                # Multithreading (PSE52)
filesystem = true               # Filesystem support
networking = true               # Networking (SLIP + IPv4)
usb = false                     # USB (optional, device-specific)
crypto = false                  # Cryptography (optional)
gui = false                     # GUI (too heavy)
floating_point = false          # No FP (use fixed-point)
dynamic_loading = false         # No runtime module loading

# ───────────────────────────────────────────────────────────────────
# DEBUGGING & DIAGNOSTICS
# ───────────────────────────────────────────────────────────────────

[debug]
enable_gdb_stub = true          # On-device GDB stub (optional)
enable_uart_console = true      # UART console for printf
enable_assertions = true        # Runtime assertions
enable_profiling = false        # Profiling (optional, costs RAM)
enable_tracing = false          # Execution tracing
enable_stack_canaries = true    # Stack overflow detection

# ───────────────────────────────────────────────────────────────────
# EXAMPLES COMPATIBLE WITH THIS PROFILE
# ───────────────────────────────────────────────────────────────────

[examples]
compatible = [
    "multitasking_demo",        # 8-16 tasks, preemptive
    "filesystem_demo",          # File I/O (RAMFS, ROMFS, EEPFS)
    "slip_networking",          # SLIP + IPv4 networking
    "door_rpc_demo",            # Inter-task Door RPC
    "sensor_logging",           # ADC + EEPROM logging
    "uart_server",              # Multi-UART handling
    "priority_scheduling"       # Priority-based scheduling demo
]

# ───────────────────────────────────────────────────────────────────
# NOTES
# ───────────────────────────────────────────────────────────────────

[notes]
summary = """
Mid-range profile for enhanced 8-bit and 16-bit microcontrollers.
Provides preemptive multitasking, filesystem support, and networking.
Suitable for IoT sensors, data logging, and networked control systems.
Limited dynamic memory (1 KB heap). No fork/exec or full TCP/IP stack.
"""

limitations = """
- No fork/exec (process management stubs)
- Limited heap: 1 KB (use fixed-size pools)
- No full TCP/IP (SLIP + basic IPv4 only)
- No signals or advanced IPC
- No select/poll (manual polling required)
- Stack space limited (128 bytes per task)
"""

best_practices = """
1. Use preemptive scheduling for responsive tasks
2. Leverage Door RPC for efficient inter-task communication
3. Store read-only data in ROMFS (flash)
4. Log to EEPROM with wear-leveling (TinyLog-4)
5. Use fixed-size memory pools instead of malloc
6. Profile RAM usage carefully (stay under budget)
7. Enable stack guards to catch overflow early
8. Test with GDB stub for debugging
"""

atmega128_specific = """
ATmega128 has 4 KB SRAM - suitable for mid-range profile:
- Scheduler: 8-12 tasks @ 128 bytes stack each = 1-1.5 KB
- Heap: 1 KB
- Door slab: 128 bytes
- Filesystem cache: 512 bytes
- Globals: ~512 bytes
- Free margin: ~512 bytes

Example allocation:
  8 tasks × 128 B = 1024 B
  Heap            = 1024 B
  FS cache        =  512 B
  Door slab       =  128 B
  Globals         =  512 B
  Stack margin    =  512 B (safety)
  ─────────────────────────
  Total           = 3712 B (~90% of 4 KB)
"""
