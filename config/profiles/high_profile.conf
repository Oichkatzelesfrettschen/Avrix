# ═══════════════════════════════════════════════════════════════════
#  Avrix High-End Profile Configuration
#  Target: 32-bit MCUs with rich resources (16KB-1MB RAM, 128KB-2MB Flash)
# ═══════════════════════════════════════════════════════════════════
#
#  POSIX Profile: PSE53/PSE54 (Full POSIX with filesystem and processes)
#  Features: Full preemptive multitasking, filesystem, networking, MPU
#  Advanced: Dynamic memory, full TCP/IP stack, optional process isolation
#
#  Example Targets:
#  - STM32F4 (192KB SRAM, 1MB Flash, ARM Cortex-M4)
#  - STM32H7 (1MB SRAM, 2MB Flash, ARM Cortex-M7)
#  - PIC32MZ (512KB RAM, 2MB Flash, MIPS M-class)
#  - NRF52840 (256KB RAM, 1MB Flash, ARM Cortex-M4)
#  - SAMD51 (256KB RAM, 512KB Flash, ARM Cortex-M4)
#  - ATmega1284P (16KB SRAM, 128KB Flash) - high-end 8-bit
#
# ═══════════════════════════════════════════════════════════════════

[profile]
name = "high-end"
tier = "high"
description = "32-bit MCUs with rich resources"
posix_profile = "PSE54"         # Full POSIX
min_ram_bytes = 16384           # 16 KB
max_ram_bytes = 1048576         # 1 MB
min_flash_bytes = 131072        # 128 KB
max_flash_bytes = 2097152       # 2 MB

# ───────────────────────────────────────────────────────────────────
# SCHEDULER CONFIGURATION
# ───────────────────────────────────────────────────────────────────

[scheduler]
type = "full"                   # Options: simple, preemptive, full
mode = "preemptive"             # Preemptive multitasking
max_tasks = 64                  # Maximum number of tasks
stack_size_bytes = 512          # Per-task stack size (generous)
quantum_ms = 5                  # Time-slice: 5 ms
priority_levels = 32            # 0 (high) to 31 (low)
scheduling_policy = "priority_rr"  # Priority round-robin
enable_sleep = true             # Task sleep support
enable_dag_wait = true          # DAG dependency tracking
enable_stack_guard = true       # Stack overflow detection
tick_frequency_hz = 1000        # 1 kHz system tick

# Advanced scheduling
enable_realtime = true          # Real-time scheduling (SCHED_FIFO, SCHED_RR)
enable_deadline = false         # EDF (Earliest Deadline First)
enable_smp = false              # SMP support (future)

# ───────────────────────────────────────────────────────────────────
# MEMORY MANAGEMENT
# ───────────────────────────────────────────────────────────────────

[memory]
allocator = "full"              # Options: none, bump, fixed_pool, full
heap_size_bytes = 65536         # 64 KB heap for dynamic allocation
enable_malloc = true            # malloc/free available
enable_mpu = true               # Memory Protection Unit (if available)
static_only = false             # Dynamic allocation encouraged

# Heap configuration
enable_slab_allocator = true    # Slab allocator for efficiency
enable_heap_fragmentation_tracking = true
enable_heap_guard_pages = true  # Guard pages (with MPU)

# MPU configuration
mpu_regions = 8                 # Number of MPU regions
enable_kernel_mode = true       # Separate kernel/user mode
enable_process_isolation = true # Per-process memory protection

# ───────────────────────────────────────────────────────────────────
# IPC & SYNCHRONIZATION
# ───────────────────────────────────────────────────────────────────

[ipc]
enable_door_rpc = true          # Door RPC (zero-copy IPC)
door_slots_per_task = 8         # Door descriptors per task
door_slab_size_bytes = 256      # Shared payload buffer
enable_pipes = true             # POSIX pipes
enable_message_queues = true    # POSIX message queues
enable_shared_memory = true     # Shared memory (with MPU)

# Pipe configuration
pipe_buffer_size = 1024         # Pipe buffer size
max_pipes = 16                  # Max concurrent pipes

# Message queue configuration
mq_max_messages = 32            # Max messages per queue
mq_message_size = 256           # Max message size

[sync]
enable_spinlock = true          # Spinlocks
enable_mutex = true             # POSIX mutexes
enable_semaphore = true         # POSIX semaphores
enable_rwlock = true            # Read-write locks
enable_condvar = true           # Condition variables
enable_barrier = true           # Barriers
lock_type = "atomic_fair"       # Options: simple_tas, tas_with_fair, atomic, atomic_fair

# Priority inheritance
enable_priority_inheritance = true   # Priority inheritance protocol
enable_priority_ceiling = true       # Priority ceiling protocol

# ───────────────────────────────────────────────────────────────────
# FILESYSTEM
# ───────────────────────────────────────────────────────────────────

[filesystem]
enable = true                   # Filesystem support
vfs = true                      # VFS layer
types = ["ramfs", "romfs", "fatfs", "littlefs"]  # Available FS types
max_open_files = 32             # Max open file descriptors
max_path_length = 256           # Max path string length
enable_cwd = true               # Current working directory
enable_symlinks = false         # Symbolic links (optional)
enable_permissions = false      # File permissions (simplified)

# RAMFS (in-memory filesystem)
ramfs_size_kb = 8               # 8 KB RAMFS
ramfs_inodes = 64               # Number of inodes

# ROMFS (read-only filesystem in flash)
romfs_enable = true             # Enable ROMFS
romfs_max_files = 128           # Max files in ROMFS

# FAT filesystem (SD card, external flash)
fatfs_enable = true             # Enable FAT12/16/32
fatfs_cache_size = 2048         # Cache size

# LittleFS (wear-leveling flash FS)
littlefs_enable = true          # Enable LittleFS
littlefs_block_size = 256       # Block size
littlefs_block_count = 512      # Number of blocks

# ───────────────────────────────────────────────────────────────────
# NETWORKING
# ───────────────────────────────────────────────────────────────────

[networking]
enable = true                   # Networking support
stack = "lwip"                  # Options: none, slip, minimal_tcp, lwip
protocols = ["ipv4", "ipv6", "tcp", "udp", "icmp"]
max_sockets = 16                # Max concurrent sockets
enable_dns = true               # DNS resolver
enable_dhcp = true              # DHCP client
enable_http_server = false      # HTTP server (optional)
enable_ftp_server = false       # FTP server (optional)

# lwIP configuration
lwip_mem_size = 16384           # lwIP memory pool
lwip_pbuf_pool_size = 32        # Packet buffer pool
lwip_tcp_mss = 1460             # TCP MSS
lwip_tcp_wnd = 5840             # TCP window size

# Ethernet (if available)
enable_ethernet = true          # Ethernet MAC/PHY
eth_mtu = 1500                  # Ethernet MTU

# ───────────────────────────────────────────────────────────────────
# DRIVERS
# ───────────────────────────────────────────────────────────────────

[drivers]
enable_uart = true              # UART
uart_count = 4                  # Multiple UARTs
enable_spi = true               # SPI
spi_count = 2                   # Multiple SPI
enable_i2c = true               # I2C
i2c_count = 2                   # Multiple I2C
enable_gpio = true              # GPIO
enable_timer = true             # System timer
enable_rtc = true               # Real-time clock
enable_adc = true               # ADC
enable_dac = true               # DAC
enable_pwm = true               # PWM
enable_watchdog = true          # Watchdog timer
enable_dma = true               # DMA controller
enable_usb = true               # USB device/host
enable_ethernet = true          # Ethernet MAC/PHY
enable_sdio = true              # SD card interface
enable_can = false              # CAN bus (optional)

# ───────────────────────────────────────────────────────────────────
# POSIX API
# ───────────────────────────────────────────────────────────────────

[posix]
profile = "PSE54"               # Full POSIX

# Process management (limited without MMU)
fork = "limited"                # fork() with MPU (limited)
exec = "limited"                # exec*() limited (no dynamic loader yet)
waitpid = "full"                # waitpid()
getpid = "full"                 # getpid()
exit = "full"                   # exit()

# I/O (full filesystem)
open = "full"                   # open() with VFS
read = "full"                   # read()
write = "full"                  # write()
close = "full"                  # close()
lseek = "full"                  # lseek()
stat = "full"                   # stat() / fstat()
ioctl = "full"                  # ioctl()
fcntl = "basic"                 # fcntl()

# unistd
sleep = "full"                  # sleep()
usleep = "full"                 # usleep()
getcwd = "full"                 # getcwd()
chdir = "full"                  # chdir()
unlink = "full"                 # unlink()
rmdir = "full"                  # rmdir()
mkdir = "full"                  # mkdir()

# Threading (full PSE54)
pthread_create = "full"         # pthread_create()
pthread_join = "full"           # pthread_join()
pthread_exit = "full"           # pthread_exit()
pthread_mutex = "full"          # pthread_mutex_*
pthread_cond = "full"           # pthread_cond_*
pthread_rwlock = "full"         # pthread_rwlock_*
pthread_barrier = "full"        # pthread_barrier_*
pthread_spin = "full"           # pthread_spinlock_*

# Signals (basic support)
signal = "basic"                # signal() basic handlers
kill = "basic"                  # kill() send signal
sigaction = "stub"              # sigaction() (advanced, stub)

# Sockets (full networking)
socket = "full"                 # socket()
bind = "full"                   # bind()
connect = "full"                # connect()
listen = "full"                 # listen()
accept = "full"                 # accept()
send = "full"                   # send() / sendto()
recv = "full"                   # recv() / recvfrom()
select = "full"                 # select()
poll = "basic"                  # poll() (basic implementation)

# ───────────────────────────────────────────────────────────────────
# BUILD & OPTIMIZATION
# ───────────────────────────────────────────────────────────────────

[build]
optimization = "2"              # -O2 (optimize for performance)
lto = true                      # Link-time optimization
debug_symbols = true            # Debug symbols in debug builds
assertions = true               # Runtime assertions
warnings_as_errors = true       # Treat warnings as errors
stack_usage_check = false       # Not critical with large stacks
size_gate = false               # No size gate (plenty of space)

# Size limits (generous)
flash_limit_bytes = 1048576     # 1 MB flash (no hard limit)
ram_limit_bytes = 262144        # 256 KB SRAM (no hard limit)
stack_limit_per_task = 512      # 512 bytes per task stack

# ───────────────────────────────────────────────────────────────────
# FEATURES
# ───────────────────────────────────────────────────────────────────

[features]
threading = true                # Multithreading
filesystem = true               # Full filesystem support
networking = true               # Full TCP/IP stack (lwIP)
usb = true                      # USB device/host
crypto = true                   # Cryptography (AES, SHA, etc.)
gui = false                     # GUI (optional, heavy)
floating_point = true           # FPU support (if available)
dynamic_loading = false         # Dynamic module loading (future)

# ───────────────────────────────────────────────────────────────────
# DEBUGGING & DIAGNOSTICS
# ───────────────────────────────────────────────────────────────────

[debug]
enable_gdb_stub = true          # On-device GDB stub
enable_uart_console = true      # UART console
enable_assertions = true        # Runtime assertions
enable_profiling = true         # Profiling support
enable_tracing = true           # Execution tracing
enable_stack_canaries = true    # Stack overflow detection
enable_heap_tracking = true     # Heap allocation tracking
enable_semihosting = false      # Semihosting (debugger I/O)

# ───────────────────────────────────────────────────────────────────
# EXAMPLES COMPATIBLE WITH THIS PROFILE
# ───────────────────────────────────────────────────────────────────

[examples]
compatible = [
    "full_posix_demo",          # All POSIX features
    "tcp_server",               # TCP/IP server (lwIP)
    "http_client",              # HTTP client
    "usb_mass_storage",         # USB MSC device
    "filesystem_stress",        # FS performance test
    "multithreading_stress",    # 32+ tasks
    "realtime_scheduling",      # SCHED_FIFO / SCHED_RR
    "network_logger",           # TCP logging + FS
    "sensor_fusion",            # ADC + IMU + Kalman filter
    "encrypted_storage"         # AES + LittleFS
]

# ───────────────────────────────────────────────────────────────────
# NOTES
# ───────────────────────────────────────────────────────────────────

[notes]
summary = """
High-end profile for 32-bit microcontrollers with rich resources.
Provides full preemptive multitasking, comprehensive filesystem support,
full TCP/IP networking (lwIP), and optional MPU-based process isolation.
Suitable for IoT gateways, data acquisition systems, HMI controllers,
and embedded Linux-like applications.
"""

capabilities = """
- Full POSIX PSE54 compliance (multi-process, filesystem, networking)
- Up to 64 concurrent tasks with priority scheduling
- Real-time scheduling policies (SCHED_FIFO, SCHED_RR)
- Full TCP/IP stack (lwIP with IPv4/IPv6, TCP, UDP, DNS, DHCP)
- Multiple filesystems (RAMFS, ROMFS, FAT, LittleFS)
- USB device/host support
- Cryptography (AES, SHA, HMAC)
- Hardware-accelerated floating-point (if FPU available)
- MPU-based memory protection (if supported)
"""

limitations = """
- No full fork/exec (limited by lack of MMU on most MCUs)
- No demand paging or virtual memory (no MMU)
- Limited process isolation (MPU provides basic protection)
- Dynamic loading not yet supported
- GUI support optional (requires external library)
"""

best_practices = """
1. Use preemptive scheduling with priority levels
2. Leverage MPU for memory protection between tasks
3. Use lwIP for production networking
4. Store logs and config on LittleFS (wear-leveling)
5. Enable profiling and tracing for performance analysis
6. Use hardware crypto acceleration when available
7. Implement watchdog for fault recovery
8. Use DMA for high-throughput I/O
9. Separate kernel and user stacks (with MPU)
10. Test with GDB stub and JTAG debugger
"""

stm32f4_specific = """
STM32F407 has 192 KB SRAM - ideal for high-end profile:
- Scheduler: 32 tasks @ 512 bytes stack = 16 KB
- Heap: 64 KB
- lwIP: 16 KB
- Filesystem cache: 8 KB
- USB buffers: 4 KB
- Driver buffers: 8 KB
- Globals: 16 KB
- Free margin: 60 KB (30%)
  ─────────────────────────
  Total: ~132 KB (~69% of 192 KB)

Recommended configuration:
- Enable MPU for process isolation
- Use LittleFS on external SPI flash
- lwIP on Ethernet MAC (10/100 Mbps)
- USB device mode for firmware updates
- Hardware crypto for TLS/DTLS
"""

atmega1284p_specific = """
ATmega1284P with 16 KB SRAM is the top-tier 8-bit MCU:
- Can run a trimmed-down high-end profile
- Disable lwIP (use SLIP instead)
- Reduce max_tasks to 16
- Reduce heap to 4 KB
- No MPU (not available on AVR)
- Still supports: threading, FS, basic networking, crypto

This bridges the gap between mid-range and true high-end.
"""
